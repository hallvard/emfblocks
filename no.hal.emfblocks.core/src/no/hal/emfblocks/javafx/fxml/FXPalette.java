package no.hal.emfblocks.javafx.fxml;

import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.layout.CornerRadii;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import no.hal.emfblocks.WPalette;
import no.hal.emfblocks.WRoot;
import no.hal.emfblocks.javafx.FXBlock;
import no.hal.emfblocks.util.data.property.PropertyListener;

public class FXPalette extends Pane implements WPaneUI
{	
	private WRoot root;
	private WPalette model;
	private Pane myPane;
	private PropertyListener<Short> spacingUpdater = (prop, oldVal, newVal) -> {updateSpacing();};
	private int ySpacing;
	private int xSpacing;
	

	/**Create an FXPalette without a model object. 
	 * The model object must be assigned later. There are two mechanisms for this.
	 * <ul>
	 * <li>The model object can be automatically generated by calling {@link #getModel(WRoot)}</li>
	 * <li>The model object can be explicitly set by calling {@link #setModel(WPalette)}</li>
	 * </ul>
	 * If {@link WRoot#installContentPane(javafx.scene.Parent)} is called and this object is in the node structure, 
	 * then model objects are automatically created using the first mechanism, unless they have already been assigned*/
	public FXPalette()
	{
		this(null);
	}
	
	/**Constructor used by the {@link WPalette} object. Automatically assigns the model.*/
	public FXPalette(WPalette model)
	{
		super();
		myPane = this;
		myPane.setBackground(new Background(new BackgroundFill(Color.DARKGRAY, CornerRadii.EMPTY, Insets.EMPTY)));
		if(model != null)
			setModel(model);
	}
	
	@Override
	public WPalette getModel(WRoot root)
	{
		if(model == null)
		{
			WPalette m = new WPalette(root, null, this);
			//root.add(m);
			setModel(m);
		}
		else
			assert model.getRoot() == root : this+" was assigned to root "+root+", but the model's root is "+model.getRoot()+"!";
		return model;
	}
	/**Sets the model to the specified instance. The panel will be cleared of any blocks from the old model if necessary.*/
	public void setModel(WPalette m)
	{
		if(root != null && m.getRoot() != root)
		{
			root.getTypeHierarchy().connectorHeight.removeListener(null, spacingUpdater );
			root = null;
		}
		if(root == null)
		{
			root = m.getRoot();
			updateSpacing();
			root.getTypeHierarchy().connectorHeight.addListener(null , spacingUpdater);
		}
		getChildren().clear();
		model = m;
	}
	
	private void updateSpacing()
	{
		ySpacing = root.getTypeHierarchy().connectorHeight.get()+2;
		xSpacing = ySpacing;
		requestLayout();
	}
	
	@Override
	protected double computeMinWidth(double height)
	{
		int maxWidth = 0;
		for(Node c :getChildren())
		{
			if(c instanceof FXBlock)
				maxWidth = Math.max(maxWidth, ((FXBlock) c).getRealWidth());
			else
				System.err.println("Unknown node in palette:_"+c);
		}
		return maxWidth+xSpacing*2;
	}
	@Override
	protected double computeMinHeight(double width)
	{
		int height = ySpacing;
		for(Node c :getChildren())
		{
			if(c instanceof FXBlock)
				height += ((FXBlock) c).getRealHeight() + ySpacing;
			else
				System.err.println("Unknown node in palette:_"+c);
		}
		return height;
	}
	
	@Override
	protected double computePrefWidth(double height)
	{
		return computeMinWidth(height);
	}
	@Override
	protected double computePrefHeight(double width)
	{
		return computeMinHeight(width);
	}
	
	protected void layoutChildren()
	{
		int y = ySpacing;
		for(Node c :getChildren())
		{
			if(c instanceof FXBlock)
			{
				c.relocate(xSpacing, y);
				y += ((FXBlock) c).getRealHeight()+ySpacing;
			}
			else
				System.err.println("Unknown node in palette:_"+c);
		}
	}
}
